Часть 1.

a. Начиная примерно с N = 20 продолжайте увеличивать N с шагом 5 до тех пор, пока вычисление fib_p(N) будет занимать меньше пяти секунд. При каком N это условие перестает выполняться? Почему так происходит?

- Примерно начиная с N = 50. Два рекурсивных вызова имеют экпоненциальную алгоритмическую сложность, в отличие от хвостовой реализации. Поэтому при дальнейшем увеличении N время вычислений будет только расти за счет накопления в стеке промежуточных рекурсивных результатов.

b. Сколько времени тратится на вычисление tail_fib(10000)? Почему?
	
- При применении хвостовой рекурсии для нахождения чисел Фибоначчи, линейный процесс преобразуется в итеративный. За счет такой оптимизации в стеке не скапливаются какие либо рекурсивные вызовы и вычисления производятся весьма быстро.
- Замерю время выполнения вызова функции fib:tail_fib(10_000) посредством стандартной функции timer:tc/3:
	timer:tc(fib, tail_fib, [10_000], microsecond).
	{819, 336447648764317832666216120051075433103021484606800 ... 310059947366875}
- Результат составил 819 мкс.

Часть 2.
Первый ряд из чисел делящихся на квадрат простого числа длиной 4, 5 и 6 при MaxN равное 30_000. Так же замерю время время выполнения вызова функций посредством стандартной функции timer:tc/3:
- При 4:
	mobius:find_square_multiples(4, 30_000).
	29887
	timer:tc(mobius, find_square_multiples, [4, 30_000], microsecond).
	Время вычислений - 2048
	Результат - 29887
- При 5:
	mobius:find_square_multiples(5, 30_000).
	29348
	timer:tc(mobius, find_square_multiples, [5, 30_000], microsecond).
	Время вычислений - 10240
	Результат - 29348
- При 6:	
	mobius:find_square_multiples(6, 30_000).
	24647
	timer:tc(mobius, find_square_multiples, [6, 30_000], microsecond).
	Время вычислений - 74137
	Результат - 24647
